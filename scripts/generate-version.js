#!/usr/bin/env node

/**
 * Version Generator Script
 *
 * Generates a version.ts file for the dashboard with:
 * - APP_VERSION from package.json
 * - BUILD_DATE (ISO timestamp)
 * - COMMIT_HASH (short git hash)
 *
 * Usage: node scripts/generate-version.js
 *
 * This runs automatically before builds via npm scripts.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Read version from root package.json
const rootPkgPath = path.join(__dirname, '..', 'package.json');
const dashboardPkgPath = path.join(__dirname, '..', 'dashboard', 'package.json');

let version = '0.0.0';
let dashboardVersion = '0.0.0';

try {
  const rootPkg = JSON.parse(fs.readFileSync(rootPkgPath, 'utf8'));
  version = rootPkg.version || '0.0.0';
} catch (error) {
  console.warn('⚠️ Could not read root package.json, using default version');
}

try {
  const dashboardPkg = JSON.parse(fs.readFileSync(dashboardPkgPath, 'utf8'));
  dashboardVersion = dashboardPkg.version || version;
} catch (error) {
  dashboardVersion = version;
}

// Get git commit hash
let commitHash = 'unknown';
try {
  commitHash = execSync('git rev-parse --short HEAD', {
    encoding: 'utf8',
    stdio: ['pipe', 'pipe', 'pipe']
  }).trim();
} catch (error) {
  console.warn('⚠️ Could not get git commit hash');
}

// Get git branch name
let branchName = 'unknown';
try {
  branchName = execSync('git rev-parse --abbrev-ref HEAD', {
    encoding: 'utf8',
    stdio: ['pipe', 'pipe', 'pipe']
  }).trim();
} catch (error) {
  console.warn('⚠️ Could not get git branch name');
}

// Check if working directory is dirty
let isDirty = false;
try {
  const status = execSync('git status --porcelain', {
    encoding: 'utf8',
    stdio: ['pipe', 'pipe', 'pipe']
  }).trim();
  isDirty = status.length > 0;
} catch (error) {
  // Ignore
}

const buildDate = new Date().toISOString();

// Generate TypeScript content
const content = `/**
 * THIS FILE IS AUTO-GENERATED BY scripts/generate-version.js
 * DO NOT EDIT MANUALLY - changes will be overwritten on next build
 *
 * Generated: ${buildDate}
 */

/** Application version from package.json */
export const APP_VERSION = '${dashboardVersion}';

/** ISO timestamp of when this build was created */
export const BUILD_DATE = '${buildDate}';

/** Short git commit hash (e.g., 'a4f32x7') */
export const COMMIT_HASH = '${commitHash}';

/** Git branch name at build time */
export const BRANCH_NAME = '${branchName}';

/** Whether the build was from a dirty working directory */
export const IS_DIRTY = ${isDirty};

/** Full version string for display (e.g., 'v1.2.0 (a4f32x7)') */
export const VERSION_STRING = \`v\${APP_VERSION} (\${COMMIT_HASH})\${IS_DIRTY ? '*' : ''}\`;

/** Build info object for debugging */
export const BUILD_INFO = {
  version: APP_VERSION,
  commit: COMMIT_HASH,
  branch: BRANCH_NAME,
  date: BUILD_DATE,
  dirty: IS_DIRTY,
} as const;
`;

// Write to dashboard/lib/version.ts
const outputDir = path.join(__dirname, '..', 'dashboard', 'lib');
const outputPath = path.join(outputDir, 'version.ts');

// Ensure directory exists
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

fs.writeFileSync(outputPath, content);

console.log(`✅ Generated ${outputPath}`);
console.log(`   Version: ${dashboardVersion}`);
console.log(`   Commit:  ${commitHash}${isDirty ? ' (dirty)' : ''}`);
console.log(`   Branch:  ${branchName}`);
console.log(`   Date:    ${buildDate}`);
